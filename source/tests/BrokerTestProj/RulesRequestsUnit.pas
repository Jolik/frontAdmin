unit RulesRequestsUnit;

interface

procedure ExecuteRulesRequest;

implementation

uses
  System.SysUtils,
  System.JSON,
  IdHTTP,
  RulesRestBrokerUnit,
  RuleHttpRequests,
  RuleUnit,
  SmallRuleUnit,
  BaseResponses;

procedure ExecuteRulesRequest;
var
  Broker: TRulesRestBroker;
  ListRequest: TRuleReqList;
  ListResponse: TRuleListResponse;
  InfoRequest: TRuleReqInfo;
  InfoResponse: TRuleInfoResponse;
  NewRequest: TRuleReqNew;
  NewResponse: TRuleNewResponse;
  UpdateRequest: TRuleReqUpdate;
  UpdateResponse: TJSONResponse;
  RemoveRequest: TRuleReqRemove;
  RemoveResponse: TJSONResponse;
  RuleBody: TRule;
  UpdateBody: TRule;
  SmallRule: TSmallRule;
  ChannelsObject: TJSONObject;
  ChannelsArray: TJSONArray;
  CreatedRuleId: string;
  ListRule: TRule;
  ItemIndex: Integer;
  MaxItemsToDisplay: Integer;
begin
  // Initialize all interface references with nil to avoid accidental access violations
  // in the finally block when the procedure exits because of an exception.
  Broker := nil;
  ListRequest := nil;
  ListResponse := nil;
  InfoRequest := nil;
  InfoResponse := nil;
  NewRequest := nil;
  NewResponse := nil;
  UpdateRequest := nil;
  UpdateResponse := nil;
  RemoveRequest := nil;
  RemoveResponse := nil;
  RuleBody := nil;
  UpdateBody := nil;
  SmallRule := nil;
  ChannelsObject := nil;
  ChannelsArray := nil;
  CreatedRuleId := '';

  try
    // The broker wraps all HTTP calls to the /router/rules REST endpoint.
    Broker := TRulesRestBroker.Create('ST-Test');

    // Request factories are obtained from the broker to make sure the base path
    // and default headers are configured consistently for every HTTP call.
    ListRequest := Broker.CreateReqList as TRuleReqList;
    InfoRequest := Broker.CreateReqInfo as TRuleReqInfo;
    NewRequest := Broker.CreateReqNew as TRuleReqNew;
    UpdateRequest := Broker.CreateReqUpdate as TRuleReqUpdate;
    RemoveRequest := Broker.CreateReqRemove as TRuleReqRemove;

    try
      // Limit the number of rules returned by the list request so the console output
      // stays readable even on installations that contain thousands of rules.
      if Assigned(ListRequest.Body) then
      begin
        ListRequest.Body.Page := 1;
        ListRequest.Body.PageSize := 5;
        ListRequest.Body.Order := 'priority';
        ListRequest.Body.OrderDir := 'desc';
      end;

      // Compose a brand new rule entity that will be sent in the create request body.
      if Assigned(NewRequest.ReqBody) and (NewRequest.ReqBody is TRule) then
      begin
        RuleBody := TRule(NewRequest.ReqBody);

        // Generate a predictable identifier so that subsequent requests (update/info/remove)
        // can refer to the same rule even when the server does not echo the identifier back.
        CreatedRuleId := 'autotest-rule-' + Copy(TGUID.NewGuid.ToString.Replace('{', '').Replace('}', ''), 1, 8);
        RuleBody.Ruid := CreatedRuleId;
        RuleBody.Name := 'AutoRule_' + Copy(CreatedRuleId, 1, 8);
        RuleBody.Caption := 'Automatically created router rule for broker smoke tests';
        RuleBody.Def := 'This rule was generated by BrokerTestProj to validate TRulesRestBroker CRUD calls.';
        RuleBody.Enabled := True;

        SmallRule := RuleBody.Rule;
        if Assigned(SmallRule) then
        begin
          // Basic routing settings describing how the rule should be executed inside the router service.
          SmallRule.Position := 10;
          SmallRule.Priority := 100;
          SmallRule.Doubles := False;
          SmallRule.BreakRule := False;
          SmallRule.Enabled := True;

          // Provide an explicit handler pipeline so the request payload contains a realistic array value.
          SmallRule.Handlers.ClearStrings;
          SmallRule.Handlers.AddString('router.demo.validate');
          SmallRule.Handlers.AddString('router.demo.dispatch');

          // Channels are modeled as a JSON object (name + array of destinations).
          // Creating the JSON structure manually and letting the helper parse it keeps the code compact
          // and guarantees that the request body matches the production format.
          SmallRule.Channels.Clear;
          ChannelsObject := TJSONObject.Create;
          try
            ChannelsArray := TJSONArray.Create;
            ChannelsArray.AddElement(TJSONString.Create('demo-channel-primary'));
            ChannelsObject.AddPair('sms', ChannelsArray);

            ChannelsArray := TJSONArray.Create;
            ChannelsArray.AddElement(TJSONString.Create('email-broadcast'));
            ChannelsArray.AddElement(TJSONString.Create('email-fallback'));
            ChannelsObject.AddPair('email', ChannelsArray);

            SmallRule.Channels.Parse(ChannelsObject);
          finally
            ChannelsObject.Free;
            ChannelsObject := nil;
          end;

          // Filters are cleared to produce deterministic payloads without referencing real profile IDs.
          SmallRule.IncFilters.Clear;
          SmallRule.ExcFilters.Clear;
        end;
      end;

      // Send the POST /rules/new request to create the synthetic rule.
      NewResponse := Broker.New(NewRequest);

      Writeln('-----------------------------------------------------------------');
      Writeln('Rule create request URL: ' + NewRequest.GetURLWithParams);
      Writeln(Format('Rule create request body: %s', [NewRequest.ReqBodyContent]));
      Writeln('Rule create response:');
      if Assigned(NewResponse) and not NewResponse.Response.Trim.IsEmpty then
        Writeln(NewResponse.Response)
      else
        Writeln('(empty response body)');

      if not CreatedRuleId.IsEmpty then
      begin
        // Mirror the original request body into the update request so that only a couple of
        // fields have to be changed to simulate a user editing the rule via the UI.
        UpdateRequest.Id := CreatedRuleId;
        if Assigned(UpdateRequest.ReqBody) and (UpdateRequest.ReqBody is TRule) and
          Assigned(NewRequest.ReqBody) and (NewRequest.ReqBody is TRule) then
        begin
          UpdateBody := TRule(UpdateRequest.ReqBody);
          UpdateBody.Assign(TRule(NewRequest.ReqBody));
          UpdateBody.Caption := 'Automatically updated router rule caption';
          UpdateBody.Def := 'Updated by BrokerTestProj to demonstrate TRulesRestBroker.Update.';
          UpdateBody.Enabled := False;

          SmallRule := UpdateBody.Rule;
          if Assigned(SmallRule) then
          begin
            // Toggle several flags to prove that the update call is capable of persisting changes.
            SmallRule.Priority := SmallRule.Priority + 5;
            SmallRule.Position := SmallRule.Position + 1;
            SmallRule.BreakRule := not SmallRule.BreakRule;
            SmallRule.Handlers.AddString('router.demo.audit');
          end;
        end;

        // Issue the update call and dump the resulting JSON payload to the console.
        UpdateResponse := Broker.Update(UpdateRequest);

        Writeln('-----------------------------------------------------------------');
        Writeln('Rule update request URL: ' + UpdateRequest.GetURLWithParams);
        Writeln(Format('Rule update request body: %s', [UpdateRequest.ReqBodyContent]));
        Writeln('Rule update response:');
        if Assigned(UpdateResponse) and not UpdateResponse.Response.Trim.IsEmpty then
          Writeln(UpdateResponse.Response)
        else
          Writeln('(empty response body)');

        // Retrieve the same rule to make sure the server stored the values we sent earlier.
        InfoRequest.ID := CreatedRuleId;
        InfoResponse := Broker.Info(InfoRequest);

        Writeln('-----------------------------------------------------------------');
        Writeln('Rule info request URL: ' + InfoRequest.GetURLWithParams);
        Writeln('Rule info response:');
        if Assigned(InfoResponse) and Assigned(InfoResponse.Rule) then
        begin
          Writeln(Format('Rule caption: %s', [InfoResponse.Rule.Caption]));
          Writeln(Format('Rule enabled: %s', [BoolToStr(InfoResponse.Rule.Enabled, True)]));
          if Assigned(InfoResponse.Rule.Rule) then
          begin
            Writeln(Format('Handlers: %s',
              [string.Join(', ', InfoResponse.Rule.Rule.Handlers.ToStringArray)]));
            Writeln(Format('Priority: %d', [InfoResponse.Rule.Rule.Priority]));
          end;
        end
        else
          Writeln('Rule details were not returned in the response.');

        // Clean up the temporary rule so the test can be executed repeatedly without side effects.
        RemoveRequest.Id := CreatedRuleId;
        RemoveResponse := Broker.Remove(RemoveRequest);

        Writeln('-----------------------------------------------------------------');
        Writeln('Rule remove request URL: ' + RemoveRequest.GetURLWithParams);
        Writeln('Rule remove response:');
        if Assigned(RemoveResponse) and not RemoveResponse.Response.Trim.IsEmpty then
          Writeln(RemoveResponse.Response)
        else
          Writeln('(empty response body)');
      end
      else
      begin
        Writeln('-----------------------------------------------------------------');
        Writeln('Skipping rule update/info/remove because the creation step did not yield an ID.');
      end;

      // Execute the paged list request to show a subset of existing rules.
      ListResponse := Broker.List(ListRequest);

      Writeln('-----------------------------------------------------------------');
      Writeln('Rules list request URL: ' + ListRequest.GetURLWithParams);
      Writeln(Format('Rules list request body: %s', [ListRequest.ReqBodyContent]));
      Writeln('Rules list response:');

      if Assigned(ListResponse) and Assigned(ListResponse.RuleList) and
        (ListResponse.RuleList.Count > 0) then
      begin
        Writeln(Format('Rules returned: %d', [ListResponse.RuleList.Count]));
        MaxItemsToDisplay := ListResponse.RuleList.Count;
        if MaxItemsToDisplay > 3 then
          MaxItemsToDisplay := 3;

        for ItemIndex := 0 to MaxItemsToDisplay - 1 do
        begin
          ListRule := TRule(ListResponse.RuleList[ItemIndex]);
          Writeln(Format('  #%d: %s (%s)',
            [ItemIndex + 1, ListRule.Caption, ListRule.Ruid]));
        end;
      end
      else
        Writeln('No rules were returned in the list response.');

    except
      // Provide detailed diagnostics for both REST-level and general runtime errors.
      on E: EIdHTTPProtocolException do
        Writeln(Format('HTTP error: %d %s', [E.ErrorCode, E.ErrorMessage]));
      on E: Exception do
        Writeln('Error: ' + E.Message);
    end;

  finally
    // Release all dynamically created instances.
    RemoveResponse.Free;
    RemoveRequest.Free;
    UpdateResponse.Free;
    UpdateRequest.Free;
    NewResponse.Free;
    NewRequest.Free;
    InfoResponse.Free;
    InfoRequest.Free;
    ListResponse.Free;
    ListRequest.Free;
    Broker.Free;
  end;
end;

end.
